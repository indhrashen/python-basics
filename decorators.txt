
from time import sleep
 
def delayed_func(func):
    """Return `func`, delayed by 10 seconds."""
    def wrapper():
        print("Waiting for ten seconds...")
        sleep(10)
        # Call the function that was passed in
        func()
 
    return wrapper
 
 
@delayed_func
def print_phrase(): 
    print("Fresh Hacks Every Day")
    
    
    
    

import datetime
import time
from app_config import log
 
def log_performance(func):
    def wrapper(*args, **kwargs):
        datetime_now = datetime.datetime.now()
        log.debug(f"Function {func.__name__} being called at {datetime_now}")
        start_time = time.time()
 
        result = func(*args, **kwargs)
 
        log.debug(f"Took {time.time() - start_time} seconds")
        return result
    return wrapper
 
 
@log_performance
def calculate_squares(n):
    """Calculate the squares of the numbers 0 to n."""
    for i in range(n):
        i_squared = i**2
 
 
 
 
 
 
 
 
 import datetime
import time
from app_config import log
 
def log_performance(func):
    def wrapper(*args, **kwargs):
        datetime_now = datetime.datetime.now()
        log.debug(f"Function {func.__name__} being called at {datetime_now}")
        start_time = time.time()
 
        result = func(*args, **kwargs)
 
        log.debug(f"Took {time.time() - start_time} seconds")
        return result
    return wrapper
 
 
@log_performance
def calculate_squares(n):
    """Calculate the squares of the numbers 0 to n."""
    for i in range(n):
        i_squared = i**2



#Function with arguments

def add_decorator(original_fn):
    def decorator_fn():
        print("Hello from new")
        original_fn()
    return decorator_fn
 
@add_decorator
def add(x, y):
    print(x + y)
    
    
    
    
def add_decorator(n):
    def decorator_fn(original_fn):
        def wrapper_fn(*args, **kwargs):
            result = original_fn(*args, **kwargs)
            print(result+n)
            return result + n
        return wrapper_fn
    return decorator_fn
 
@add_decorator(2)
def add(x, y):
    return x + y
    
    
    
###uses execption handling


def exception_handler(original_fn):
    def decorator_fn(*args, **kwargs):
        try:
            return original_fn(*args, **kwargs)
        except Exception as err:
            print(err)
    return decorator_fn
 
@exception_handler
def add(x, y):
    sum = x + y
    print(sum)
    return sum
    
    
